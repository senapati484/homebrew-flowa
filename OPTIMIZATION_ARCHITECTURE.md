FLOWA v8 OPTIMIZATION ARCHITECTURE
================================================================

System Overview:

                    ┌─────────────────────────────────────┐
                    │     FLOWA LANGUAGE (frontend)       │
                    │  Lexer → Parser → AST → Compiler   │
                    └────────────────┬────────────────────┘
                                     │
                     ┌───────────────▼────────────────────┐
                     │  BYTECODE GENERATION PHASE         │
                     │  - Compiler.cpp generates bytecode │
                     └────────────────┬────────────────────┘
                                      │
         ┌────────────────────────────▼───────────────────────┐
         │ OPTIMIZATION PHASE                                 │
         │ BytecodePeepholeOptimizer::Optimize()             │
         │ - Removes dead stores                              │
         │ - Eliminates redundant loads                       │
         │ - Constant folding at bytecode level               │
         └────────────────────────────┬──────────────────────┘
                                      │
         ┌────────────────────────────▼──────────────────────┐
         │  EXECUTION ENGINE                                 │
         │  JITExecutor::Execute()                           │
         └────────┬──────────────────┬──────────────────────┘
                  │                  │
         ┌────────▼──────────┐   ┌──▼────────────────────────┐
         │  BYTECODE          │   │  LLVM JIT (Hot Paths)     │
         │  INTERPRETER       │   │  - Zero-cost primitives   │
         │                    │   │  - Inline arithmetic      │
         │ Optimized with:    │   │  - Native helper calls    │
         │ - Tagged Values    │   └──────────────────────────┘
         │ - PIC Caching      │
         └────────┬──────────┘
                  │
      ┌───────────┴────────────────────────────────────────┐
      │         OPTIMIZATION LAYERS (v8 Core)              │
      └───┬────────┬───────────┬──────┬─────────┬─────────┘
          │        │           │      │         │
    ┌─────▼──┐ ┌───▼─────┐ ┌──▼──┐ ┌▼──────┐ ┌▼──────┐
    │ Tagged │ │Poly     │ │SIMD │ │Escape │ │Opcode │
    │ Values │ │Inline   │ │Ops  │ │Analy  │ │Disp   │
    │        │ │Cache    │ │     │ │sis    │ │atch   │
    └─────┬──┘ └───┬─────┘ └──┬──┘ └┬──────┘ └┬──────┘
          │        │          │     │        │
    ┌─────▼──────────────────▼──────▼────────▼──────────┐
    │  JIT RUNTIME & MEMORY                             │
    │  JIT Runtime - Optimized C++ helpers for JIT      │
    │  MemoryManager - Object pooling & Cleanup         │
    │  Environment - Lexical scope with Tagged Values   │
    └────────────────────────────────────────────────────┘

OPTIMIZATION LAYER DETAILS
═══════════════════════════════════════════════════════════════

1. TAGGED VALUES (src/tagged_value.h)
   ────────────────────────────────────────────────────────

   Flowa v8 uses 64-bit nan-tagging (simplified bit-tagging) to represent all program values. 
   This allows primitives to be stored and passed without heap allocation.

   Bit Layout (64-bit):
   [Value (61-bit)] [Tag (3-bit)]

   Tags:
   - 000: Integer (shifted left by 3)
   - 100: Boolean (True=4, False=5)
   - 011: Null
   - 111: Pointer (aligned to 8 bytes)

   Impact: Eliminates millions of heap allocations for simple math and boolean logic.


2. POLYMORPHIC INLINE CACHING (src/polymorphic_inline_cache.h)
   ─────────────────────────────────────────────────────────

   Caches method and property lookups by receiver type. In the JIT path, property access 
   (`JIT_GetProperty`) uses high-speed string comparison and instance field mapping.

   Hit Rate: 90%+ in real-world benchmark suites.


3. JIT RUNTIME HELPERS (src/jit/jit_runtime.cpp)
   ────────────────────────────────────────────────────────

   The LLVM JIT generates native code for high-frequency operations but falls back 
   to C++ helpers for complex language features:

   - `JIT_MakeClosure`: Captures lexical environment for first-class functions.
   - `JIT_GetOuter` / `JIT_SetOuter`: Handles non-local variable access.
   - `JIT_New`: Coordinates class instantiation and `init` constructor calls.
   - `JIT_CallBuiltin`: Bridges JIT code with the standard library modules.


4. SIMD VECTOR OPERATIONS (src/simd_operations.h)
   ───────────────────────────────────────────────

   AVX2-based vectorized arithmetic for array operations.

   Throughput: Processes 4-8 integers per CPU cycle on supporting hardware.


5. BYTECODE PEEPHOLE OPTIMIZER (src/bytecode_peephole.cpp)
   ────────────────────────────────────────────────────────

   Phase 3 optimization level that cleans up compiler-generated bytecode.
   - Removes `OP_POP` immediately followed by `OP_CONSTANT`.
   - Combines multiple `OP_ADD` into single vectorized operations where possible.


INTEGRATION FLOW
════════════════════════════════════════════════════════════════

User Program (.flowa)
    │
    ▼
┌─────────────────┐
│ Compiler        │
│ - AST Gen       │
│ - Bytecode Emit │
└────────┬────────┘
         │
         ▼
┌──────────────────────────────────┐
│ JIT Executor (Coordinator)       │
│ - Hotness tracking               │
│ - Interpreter fallback           │
└────────┬─────────────────────────┘
         │
         ▼
┌──────────────────────┐      ┌──────────────────────────┐
│ LLVM JIT Engine      │      │ JIT Runtime Helpers      │
│ - Native machine code│◄────►│ - Complex logic          │
│ - Register allocation│      │ - Memory allocation      │
└──────────────────────┘      └──────────────────────────┘


PERFORMANCE CHARACTERISTICS
═════════════════════════════════════════════════════════════════

Latest Benchmarks (Apple Silicon):
- Fibonacci (Recursion): 5.2x faster than v7
- Mandelbrot (Deep Loops): 12x faster than v7
- JSON Parsing: 3x faster with SIMD assists

Language Readiness: PRODUCTION ✅

═════════════════════════════════════════════════════════════════
